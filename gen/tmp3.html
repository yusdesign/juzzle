<!DOCTYPE html>
<html>
<head>
    <title>Juzzle Generator - Inner/Outer Logic</title>
    <style>
        body { margin: 0; padding: 20px; background: #0d1117; color: #c9d1d9; font-family: 'Segoe UI', monospace; }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { color: #58a6ff; text-align: center; margin-bottom: 10px; }
        .subtitle { text-align: center; color: #8b949e; margin-bottom: 30px; }
        .controls {
            text-align: center;
            margin: 30px 0;
            padding: 25px;
            background: #161b22;
            border-radius: 12px;
            border: 1px solid #30363d;
        }
        button {
            padding: 14px 28px;
            margin: 10px;
            background: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.2s;
        }
        button:hover { 
            background: #2ea043;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.3);
        }
        button.secondary {
            background: #30363d;
        }
        button.secondary:hover {
            background: #3d444d;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }
        .piece-card {
            background: #161b22;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #30363d;
            transition: all 0.3s;
        }
        .piece-card:hover {
            border-color: #58a6ff;
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }
        .piece-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #30363d;
        }
        .piece-id {
            color: #58a6ff;
            font-weight: bold;
            font-size: 18px;
        }
        .piece-state {
            font-size: 12px;
            background: #30363d;
            padding: 4px 10px;
            border-radius: 20px;
            color: #8b949e;
        }
        .piece-svg {
            width: 100%;
            height: 240px;
            filter: drop-shadow(0 6px 12px rgba(0,0,0,0.5));
        }
        .connector-info {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 15px;
            font-size: 11px;
        }
        .connector-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }
        .inner-dot { background: #238636; }
        .outer-dot { background: #db6d28; }
        .legend {
            margin-top: 40px;
            padding: 20px;
            background: #161b22;
            border-radius: 12px;
            border: 1px solid #30363d;
        }
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .legend-icon {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        .inner-icon { 
            background: rgba(35, 134, 54, 0.15);
            border: 2px solid #238636;
        }
        .outer-icon { 
            background: rgba(219, 109, 40, 0.15);
            border: 2px solid #db6d28;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding: 20px;
            background: #161b22;
            border-radius: 12px;
            border: 1px solid #30363d;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #58a6ff;
        }
        .stat-label {
            font-size: 14px;
            color: #8b949e;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß© Juzzle Generator - Inner/Outer Connector Logic</h1>
        <div class="subtitle">Inner = Center inside square | Outer = Center outside square</div>
        
        <div class="controls">
            <button onclick="generatePieces(16)">üé≤ Generate 16 Pieces</button>
            <button onclick="generatePieces(24)">‚ú® Generate 24 Pieces</button>
            <button onclick="toggleDebug()" class="secondary">üîç Toggle Debug View</button>
            <button onclick="exportJSON()" class="secondary">üíæ Export as JSON</button>
            <button onclick="saveSVGs()" class="secondary">üìÅ Save All SVGs</button>
        </div>
        
        <div id="grid"></div>
        
        <div class="stats" id="stats">
            <!-- Stats will be populated by JavaScript -->
        </div>
        
        <div class="legend">
            <h3 style="margin-top: 0; color: #58a6ff;">üß† Connector Logic</h3>
            <div class="legend-grid">
                <div class="legend-item">
                    <div class="legend-icon inner-icon">üîò</div>
                    <div>
                        <strong style="color: #238636;">INNER Connector</strong><br>
                        <small>Center INSIDE square ‚Üí Knob protrudes INWARD<br>
                        Circle visible = KNOB | Circle hidden = HOLE</small>
                    </div>
                </div>
                <div class="legend-item">
                    <div class="legend-icon outer-icon">üî≥</div>
                    <div>
                        <strong style="color: #db6d28;">OUTER Connector</strong><br>
                        <small>Center OUTSIDE square ‚Üí Knob protrudes OUTWARD<br>
                        Circle visible = HOLE | Circle hidden = KNOB</small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // EXACT template coordinates
        const TEMPLATE = {
            square: { x: 373.83, y: 381.35, width: 355.32, height: 355.32 },
            circles: [
                { cx: 331.55, cy: 559.01 }, // Left Top - OUTER (cx < square.x)
                { cx: 414.33, cy: 559.01 }, // Left Bottom - INNER (cx > square.x)
                { cx: 688.86, cy: 559.01 }, // Right Top - INNER (cx < square.x + width)
                { cx: 771.64, cy: 559.01 }, // Right Bottom - OUTER (cx > square.x + width)
                { cx: 551.49, cy: 336.84 }, // Top Left - OUTER (cy < square.y)
                { cx: 551.49, cy: 419.63 }, // Top Right - INNER (cy > square.y)
                { cx: 551.49, cy: 694.15 }, // Bottom Left - INNER (cy < square.y + height)
                { cx: 551.49, cy: 776.94 }  // Bottom Bottom - OUTER (cy > square.y + height)
            ],
            radius: 64.65
        };

        class InnerOuterGenerator {
            constructor() {
                this.normalizeCoordinates();
                this.initializeConnectorTypes();
            }
            
            normalizeCoordinates() {
                this.square = { x: 0, y: 0, width: TEMPLATE.square.width, height: TEMPLATE.square.height };
                
                this.circles = TEMPLATE.circles.map(circle => ({
                    cx: circle.cx - TEMPLATE.square.x,
                    cy: circle.cy - TEMPLATE.square.y,
                    original: circle
                }));
            }
            
            initializeConnectorTypes() {
                // Determine if each connector is INNER (center inside square) or OUTER (center outside)
                this.connectorTypes = this.circles.map(circle => {
                    const centerInside = 
                        circle.cx >= 0 && circle.cx <= this.square.width &&
                        circle.cy >= 0 && circle.cy <= this.square.height;
                    
                    return centerInside ? 'inner' : 'outer';
                });
                
                // Side mapping for display
                this.sideMap = [
                    { side: 'left', pos: 'top', type: 'outer' },
                    { side: 'left', pos: 'bottom', type: 'inner' },
                    { side: 'right', pos: 'top', type: 'inner' },
                    { side: 'right', pos: 'bottom', type: 'outer' },
                    { side: 'top', pos: 'left', type: 'outer' },
                    { side: 'top', pos: 'right', type: 'inner' },
                    { side: 'bottom', pos: 'left', type: 'inner' },
                    { side: 'bottom', pos: 'right', type: 'outer' }
                ];
            }
            
            generatePiece() {
                // Generate random state (true = active/visible, false = inactive/hidden)
                const states = new Array(8).fill(0).map(() => Math.random() > 0.5);
                
                // Apply puzzle logic:
                // For INNER connectors: visible = KNOB (protrudes inward)
                // For OUTER connectors: visible = HOLE (knob would protrude outward from other piece)
                
                return states;
            }
            
            createSVG(states, id, color) {
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, 'svg');
                const viewBoxPadding = 80;
                svg.setAttribute('viewBox', 
                    `-${viewBoxPadding} -${viewBoxPadding} 
                     ${this.square.width + viewBoxPadding * 2} 
                     ${this.square.height + viewBoxPadding * 2}`);
                svg.setAttribute('width', '280');
                svg.setAttribute('height', '280');
                svg.setAttribute('class', 'piece-svg');
                
                // Create definitions for filters
                const defs = document.createElementNS(svgNS, 'defs');
                
                // Shadow filter for knobs
                const filter = document.createElementNS(svgNS, 'filter');
                filter.setAttribute('id', `shadow-${id}`);
                filter.setAttribute('x', '-20%');
                filter.setAttribute('y', '-20%');
                filter.setAttribute('width', '140%');
                filter.setAttribute('height', '140%');
                
                const feDropShadow = document.createElementNS(svgNS, 'feDropShadow');
                feDropShadow.setAttribute('dx', '2');
                feDropShadow.setAttribute('dy', '4');
                feDropShadow.setAttribute('stdDeviation', '6');
                feDropShadow.setAttribute('flood-color', 'rgba(0,0,0,0.5)');
                filter.appendChild(feDropShadow);
                defs.appendChild(filter);
                
                // Clip path for inner connectors
                const clipPath = document.createElementNS(svgNS, 'clipPath');
                clipPath.setAttribute('id', `clip-${id}`);
                const clipRect = document.createElementNS(svgNS, 'rect');
                clipRect.setAttribute('x', '0');
                clipRect.setAttribute('y', '0');
                clipRect.setAttribute('width', this.square.width);
                clipRect.setAttribute('height', this.square.height);
                clipPath.appendChild(clipRect);
                defs.appendChild(clipPath);
                
                svg.appendChild(defs);
                
                // Main group
                const group = document.createElementNS(svgNS, 'g');
                group.setAttribute('transform', `translate(0, 0)`);
                
                // Base square
                const square = document.createElementNS(svgNS, 'rect');
                square.setAttribute('x', '0');
                square.setAttribute('y', '0');
                square.setAttribute('width', this.square.width);
                square.setAttribute('height', this.square.height);
                square.setAttribute('fill', color);
                square.setAttribute('stroke', '#30363d');
                square.setAttribute('stroke-width', '8');
                square.setAttribute('rx', '12');
                square.setAttribute('ry', '12');
                group.appendChild(square);
                
                // Draw connectors based on type and state
                this.circles.forEach((circle, i) => {
                    const isActive = states[i];
                    const isInner = this.connectorTypes[i] === 'inner';
                    
                    if (debugMode || isActive) {
                        const connector = document.createElementNS(svgNS, 'circle');
                        connector.setAttribute('cx', circle.cx);
                        connector.setAttribute('cy', circle.cy);
                        connector.setAttribute('r', TEMPLATE.radius);
                        
                        if (isInner) {
                            // INNER connector: visible = KNOB
                            connector.setAttribute('fill', isActive ? color : 'none');
                            connector.setAttribute('stroke', isActive ? '#238636' : 'rgba(35, 134, 54, 0.3)');
                            connector.setAttribute('stroke-width', isActive ? '6' : '3');
                            if (isActive) {
                                connector.setAttribute('filter', `url(#shadow-${id})`);
                            } else {
                                connector.setAttribute('stroke-dasharray', '4,4');
                            }
                            // Clip to square for inner connectors
                            connector.setAttribute('clip-path', `url(#clip-${id})`);
                        } else {
                            // OUTER connector: visible = HOLE (knob would be from other piece)
                            connector.setAttribute('fill', isActive ? 'rgba(219, 109, 40, 0.2)' : 'none');
                            connector.setAttribute('stroke', isActive ? '#db6d28' : 'rgba(219, 109, 40, 0.3)');
                            connector.setAttribute('stroke-width', isActive ? '6' : '3');
                            if (!isActive) {
                                // Hidden outer connector = KNOB protruding outward
                                connector.setAttribute('stroke', '#db6d28');
                                connector.setAttribute('stroke-width', '4');
                                connector.setAttribute('stroke-dasharray', '2,2');
                            }
                        }
                        
                        group.appendChild(connector);
                    }
                });
                
                svg.appendChild(group);
                
                // Add center marker for reference
                const center = document.createElementNS(svgNS, 'circle');
                center.setAttribute('cx', this.square.width / 2);
                center.setAttribute('cy', this.square.height / 2);
                center.setAttribute('r', '4');
                center.setAttribute('fill', '#58a6ff');
                center.setAttribute('opacity', '0.5');
                svg.appendChild(center);
                
                return svg;
            }
            
            getConnectorInfo(states) {
                const info = { inner: { knobs: 0, holes: 0 }, outer: { knobs: 0, holes: 0 } };
                
                states.forEach((state, i) => {
                    const type = this.connectorTypes[i];
                    if (type === 'inner') {
                        if (state) info.inner.knobs++;
                        else info.inner.holes++;
                    } else {
                        if (state) info.outer.holes++;
                        else info.outer.knobs++;
                    }
                });
                
                return info;
            }
            
            getStateCode(states) {
                return states.map((state, i) => 
                    `${this.sideMap[i].side[0].toUpperCase()}${this.sideMap[i].pos[0].toUpperCase()}:${state ? '1' : '0'}`
                ).join(' ');
            }
        }

        // State
        const generator = new InnerOuterGenerator();
        let debugMode = false;
        let currentPieces = [];
        const colors = [
            '#238636', '#1f6feb', '#db6d28', '#8957e5',
            '#3fb950', '#58a6ff', '#d29922', '#a371f7',
            '#56d364', '#79c0ff', '#e3b341', '#bc8cff',
            '#7ee787', '#a5d6ff', '#f0883e', '#d2a8ff',
            '#afecaf', '#b3d4ff', '#ffa657', '#ddb7ff',
            '#c2f0c2', '#c8daf8', '#ffb77c', '#e6ccff'
        ];

        function generatePieces(count) {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            currentPieces = [];
            
            let totalInnerKnobs = 0;
            let totalOuterKnobs = 0;
            
            for (let i = 0; i < count; i++) {
                const states = generator.generatePiece();
                const color = colors[i % colors.length];
                const info = generator.getConnectorInfo(states);
                
                totalInnerKnobs += info.inner.knobs;
                totalOuterKnobs += info.outer.knobs;
                
                const pieceCard = document.createElement('div');
                pieceCard.className = 'piece-card';
                
                // Header
                const header = document.createElement('div');
                header.className = 'piece-header';
                
                const idDiv = document.createElement('div');
                idDiv.className = 'piece-id';
                idDiv.textContent = `Piece #${i + 1}`;
                
                const stateDiv = document.createElement('div');
                stateDiv.className = 'piece-state';
                stateDiv.textContent = `I:${info.inner.knobs}/${info.inner.holes} O:${info.outer.knobs}/${info.outer.holes}`;
                
                header.appendChild(idDiv);
                header.appendChild(stateDiv);
                pieceCard.appendChild(header);
                
                // SVG
                const svg = generator.createSVG(states, i, color);
                pieceCard.appendChild(svg);
                
                // Connector info
                if (debugMode) {
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'connector-info';
                    
                    generator.sideMap.forEach((side, idx) => {
                        const dot = document.createElement('span');
                        dot.className = `connector-dot ${generator.connectorTypes[idx]}-dot`;
                        
                        const span = document.createElement('span');
                        span.style.color = states[idx] ? '#c9d1d9' : '#8b949e';
                        span.textContent = `${side.side[0]}${side.pos[0]}`;
                        
                        infoDiv.appendChild(dot);
                        infoDiv.appendChild(span);
                    });
                    
                    pieceCard.appendChild(infoDiv);
                }
                
                grid.appendChild(pieceCard);
                currentPieces.push({ id: i, states, color, info });
            }
            
            // Update stats
            updateStats(totalInnerKnobs, totalOuterKnobs, count);
        }

        function updateStats(innerKnobs, outerKnobs, totalPieces) {
            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${totalPieces}</div>
                    <div class="stat-label">Total Pieces</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" style="color: #238636;">${innerKnobs}</div>
                    <div class="stat-label">Inner Knobs</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" style="color: #db6d28;">${outerKnobs}</div>
                    <div class="stat-label">Outer Knobs</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${Math.round((innerKnobs + outerKnobs) / (totalPieces * 8) * 100)}%</div>
                    <div class="stat-label">Fill Rate</div>
                </div>
            `;
        }

        function toggleDebug() {
            debugMode = !debugMode;
            generatePieces(currentPieces.length || 16);
        }

        function exportJSON() {
            const exportData = {
                meta: {
                    generated: new Date().toISOString(),
                    template: TEMPLATE,
                    pieceCount: currentPieces.length
                },
                pieces: currentPieces.map(piece => ({
                    id: piece.id,
                    color: piece.color,
                    states: piece.states,
                    connectorInfo: piece.info,
                    stateCode: generator.getStateCode(piece.states)
                }))
            };
            
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `juzzle-pieces-${new Date().getTime()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(`Exported ${currentPieces.length} pieces as JSON`);
        }

        function saveSVGs() {
            currentPieces.forEach((piece, i) => {
                const svg = generator.createSVG(piece.states, `export-${i}`, piece.color);
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svg);
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `juzzle-piece-${i + 1}.svg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            setTimeout(() => {
                alert(`Saved ${currentPieces.length} individual SVG files`);
            }, 100);
        }

        // Initialize
        generatePieces(16);
    </script>
</body>
</html>
