<!DOCTYPE html>
<html>
<head>
    <title>0h h1 Hybrid - Piece Generator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .piece-grid { display: grid; grid-template-columns: repeat(10, 60px); gap: 5px; }
        .piece { width: 60px; height: 60px; border: 1px solid #333; display: flex; 
                align-items: center; justify-content: center; font-family: monospace; }
        .corner { background-color: #ffeaa7; }
        .border { background-color: #a29bfe; }
        .field { background-color: #fd79a8; }
        .controls { margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Random Piece Generator</h1>
    
    <div class="controls">
        <button onclick="generatePieces()">Generate New Set</button>
        <button onclick="placeLockedPieces()">Place Random Locked Pieces</button>
    </div>
    
    <h2>Generated Pieces (144 total)</h2>
    <div id="pieceContainer" class="piece-grid"></div>
    
    <h2>Locked Pieces on Board</h2>
    <canvas id="boardCanvas" width="720" height="720" style="border:1px solid #ccc"></canvas>
    
    <script>
        // Complete implementation as described above
        // (Include all the code from steps 1, 2, and 3 here)

        // Complete implementation of your random piece generator
function generatePiece(type, id, seed = Date.now()) {
    // Use a simple seeded random for consistency if needed
    const rng = (multiplier) => {
        seed = (seed * 9301 + 49297) % 233280;
        return (seed / 233280) * multiplier;
    };
    
    const piece = {
        id: `piece_${id}`,
        type: type,
        color: 0, // 0=unknown, 1=red, 2=blue
        rotations: [],
        // Store original shape for reference
        baseShape: [EDGE_TYPES.FLAT, EDGE_TYPES.FLAT, EDGE_TYPES.FLAT, EDGE_TYPES.FLAT]
    };
    
    // Apply edge rules based on type
    switch(type) {
        case 'corner':
            // Corners get exactly 1 Jack and 1 Nest on adjacent sides
            const jackSide = Math.floor(rng(1) * 4);
            const nestSide = (jackSide + (rng(1) > 0.5 ? 1 : 3)) % 4; // Always adjacent
            
            piece.baseShape[jackSide] = EDGE_TYPES.JACK;
            piece.baseShape[nestSide] = EDGE_TYPES.NEST;
            // Remaining 2 sides stay FLAT
            break;
            
        case 'border':
            // Border: 1 FLAT side, 3 random J/N connectors
            const flatSide = Math.floor(rng(1) * 4);
            piece.baseShape[flatSide] = EDGE_TYPES.FLAT;
            
            // Randomly assign J/N to other 3 sides
            for (let i = 0; i < 4; i++) {
                if (i !== flatSide) {
                    piece.baseShape[i] = rng(1) > 0.5 ? EDGE_TYPES.JACK : EDGE_TYPES.NEST;
                }
            }
            break;
            
        case 'field':
            // Field: 4 random J/N connectors (completely random mix)
            for (let i = 0; i < 4; i++) {
                piece.baseShape[i] = rng(1) > 0.5 ? EDGE_TYPES.JACK : EDGE_TYPES.NEST;
            }
            break;
    }
    
    // Generate all 4 rotations
    for (let rot = 0; rot < 4; rot++) {
        const rotatedShape = [];
        for (let i = 0; i < 4; i++) {
            rotatedShape[i] = piece.baseShape[(i + rot) % 4];
        }
        
        piece.rotations.push({
            rotation: rot * 90, // degrees
            shape: rotatedShape,
            // Visual code: J=Jack, N=Nest, -=Flat
            visualCode: rotatedShape.map(e => 
                e === EDGE_TYPES.JACK ? 'J' : 
                e === EDGE_TYPES.NEST ? 'N' : '-'
            ).join(''),
            // For quick edge access
            top: rotatedShape[0],
            right: rotatedShape[1],
            bottom: rotatedShape[2],
            left: rotatedShape[3]
        });
    }
    
    return piece;
}
function initializeGameBoard(boardSize = 12) {
    const board = createEmptyGrid(boardSize);
    const allPieces = [];
    const pieceBank = [];
    
    // 1. Generate ALL pieces needed for a full board
    let pieceId = 0;
    
    // Generate corners (4 pieces)
    for (let i = 0; i < 4; i++) {
        allPieces.push(generatePiece('corner', pieceId++));
    }
    
    // Generate border pieces (excluding corners)
    // For 12x12: 10 pieces on each side minus 2 corners = 40 border pieces
    for (let i = 0; i < 40; i++) {
        allPieces.push(generatePiece('border', pieceId++));
    }
    
    // Generate field pieces (interior)
    // For 12x12: 10x10 interior = 100 field pieces
    for (let i = 0; i < 100; i++) {
        allPieces.push(generatePiece('field', pieceId++));
    }
    
    // 2. Place "random lockers" - just like 0h h1 starts with some pre-filled cells
    const numLockedPieces = Math.floor(boardSize * 1.5); // ~18 locked pieces for 12x12
    const lockedPositions = new Set();
    
    for (let locked = 0; locked < numLockedPieces; locked++) {
        let placed = false;
        let attempts = 0;
        
        while (!placed && attempts < 100) {
            attempts++;
            const row = Math.floor(Math.random() * boardSize);
            const col = Math.floor(Math.random() * boardSize);
            const positionKey = `${row},${col}`;
            
            // Skip if already locked
            if (lockedPositions.has(positionKey)) continue;
            
            // Determine piece type based on position
            let pieceType;
            if ((row === 0 || row === boardSize-1) && 
                (col === 0 || col === boardSize-1)) {
                pieceType = 'corner';
            } else if (row === 0 || row === boardSize-1 || 
                       col === 0 || col === boardSize-1) {
                pieceType = 'border';
            } else {
                pieceType = 'field';
            }
            
            // Find an unplaced piece of this type
            const availablePieces = allPieces.filter(p => 
                !p.isPlaced && p.type === pieceType
            );
            
            if (availablePieces.length > 0) {
                const piece = availablePieces[Math.floor(Math.random() * availablePieces.length)];
                piece.isPlaced = true;
                piece.isLocked = true;
                
                // Find a valid rotation for this position
                const validRotation = findValidRotation(piece, row, col, board);
                
                if (validRotation !== -1) {
                    placePieceOnBoard(board, piece, row, col, validRotation);
                    lockedPositions.add(positionKey);
                    placed = true;
                } else {
                    // If no rotation fits, unmark the piece
                    piece.isPlaced = false;
                }
            }
        }
        
        if (attempts >= 100) {
            console.warn(`Failed to place locked piece ${locked + 1}`);
        }
    }
    
    // 3. Add remaining pieces to the bank (mixed, unplaced)
    allPieces.forEach(piece => {
        if (!piece.isPlaced) {
            pieceBank.push(piece);
        }
    });
    
    // 4. Apply 0h h1 color rules to deduce locked piece colors
    deduceInitialColors(board);
    
    return {
        board: board,
        pieceBank: pieceBank,
        lockedCount: lockedPositions.size
    };
}

function findValidRotation(piece, row, col, board) {
    const boardSize = board.length;
    
    // Check each rotation
    for (let rotation = 0; rotation < 4; rotation++) {
        const edges = piece.rotations[rotation];
        let isValid = true;
        
        // Check all 4 sides
        const neighbors = [
            {dir: 'top', row: row-1, col: col, edge: edges.top},
            {dir: 'right', row: row, col: col+1, edge: edges.right},
            {dir: 'bottom', row: row+1, col: col, edge: edges.bottom},
            {dir: 'left', row: row, col: col-1, edge: edges.left}
        ];
        
        for (const neighbor of neighbors) {
            const {row: nRow, col: nCol, edge: myEdge} = neighbor;
            
            // Check if position is outside board
            if (nRow < 0 || nRow >= boardSize || nCol < 0 || nCol >= boardSize) {
                // Border must be FLAT
                if (myEdge !== EDGE_TYPES.FLAT) {
                    isValid = false;
                    break;
                }
            } 
            // Check if neighbor has a piece
            else if (board[nRow][nCol].pieceId) {
                const theirEdge = getOppositeEdge(board[nRow][nCol], neighbor.dir);
                
                // Both must be connectors (not FLAT) and compatible
                if (myEdge === EDGE_TYPES.FLAT || theirEdge === EDGE_TYPES.FLAT) {
                    isValid = false;
                    break;
                }
                
                if (!edgesCompatible(myEdge, theirEdge)) {
                    isValid = false;
                    break;
                }
            }
        }
        
        if (isValid) {
            return rotation; // Found a valid rotation!
        }
    }
    
    return -1; // No valid rotation found
}
      
        // Initialize on load
        window.onload = function() {
            generatePieces();
        };
    </script>
</body>
</html> 
